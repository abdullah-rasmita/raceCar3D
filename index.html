<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Car Runner — Driver Seat POV</title>
  <style>
    :root{
      --bg:#0b0f14;--panel:#121826;--text:#e7eefc;--muted:#9bb0d1;--accent:#5eead4;--shadow:rgba(0,0,0,.35)
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:radial-gradient(1200px 800px at 70% 10%, #182033 0%, var(--bg) 55%);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      padding-bottom:104px;
      overflow-x:hidden;
    }
    .wrap{min-height:100%;display:grid;place-items:center;padding:16px}
    .app{width:min(920px,100%);display:grid;grid-template-columns:1fr;gap:14px;align-items:start}

    .topbar{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:12px 14px;border-radius:16px;background:rgba(18,24,38,.88);
      box-shadow:0 10px 30px var(--shadow);border:1px solid rgba(255,255,255,.08);
      flex-wrap:wrap;
    }
    .title{display:flex;flex-direction:column;gap:2px;line-height:1.1;min-width:180px}
    .title strong{font-size:15px;letter-spacing:.3px}
    .title span{font-size:12px;color:var(--muted)}
    .stats{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end}

    .chip{
      display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:999px;
      background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);
      font-size:12px;user-select:none;white-space:nowrap
    }
    .chip b{font-variant-numeric:tabular-nums}
    .dot{width:8px;height:8px;border-radius:999px;background:var(--accent);box-shadow:0 0 0 4px rgba(94,234,212,.12)}
    .dot.gray{background:rgba(255,255,255,.35);box-shadow:0 0 0 4px rgba(255,255,255,.06)}
    .dot.blue{background:#60a5fa;box-shadow:0 0 0 4px rgba(96,165,250,.12)}
    .dot.green{background:#34d399;box-shadow:0 0 0 4px rgba(52,211,153,.12)}
    .dot.purple{background:#a78bfa;box-shadow:0 0 0 4px rgba(167,139,250,.12)}

    .btn{
      appearance:none;border:0;border-radius:12px;padding:10px 12px;color:var(--text);
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10);
      cursor:pointer;font-weight:700;font-size:12px;letter-spacing:.2px;
      transition:transform .08s ease, background .2s ease, border-color .2s ease;user-select:none
    }
    .btn:hover{background:rgba(255,255,255,.11)}
    .btn:active{transform:translateY(1px) scale(.99)}
    .btn.primary{background:rgba(94,234,212,.14);border-color:rgba(94,234,212,.24)}
    .btn.primary:hover{background:rgba(94,234,212,.18)}
    .btn.warn{background:rgba(251,113,133,.14);border-color:rgba(251,113,133,.24)}
    .btn.warn:hover{background:rgba(251,113,133,.18)}

    .stage{
      position:relative;
      width:min(520px,100%);
      margin:0 auto;
      border-radius:18px;
      overflow:hidden;
      background:linear-gradient(#0c1220,#0a0f1a);
      border:1px solid rgba(255,255,255,.10);
      box-shadow:0 20px 60px var(--shadow);
      height: var(--stageH, 72vh);
      max-height: 820px;
      min-height: 420px;
      touch-action:none;
    }
    canvas{
      display:block;
      width:100%;
      height:100%;
      background:
        radial-gradient(900px 600px at 50% -20%, rgba(94,234,212,.08) 0%, transparent 55%),
        linear-gradient(#0a1020,#070b12);
    }

    /* === DRIVER SEAT OVERLAYS === */
    .pov {
      position:absolute; inset:0;
      pointer-events:none;
      z-index:15; /* below overlay menu (20) but above canvas */
    }

    /* Windshield tint + top frame */
    .windshield-top {
      position:absolute; left:0; right:0; top:0;
      height: 18%;
      background: linear-gradient(to bottom,
        rgba(0,0,0,0.55),
        rgba(0,0,0,0.15),
        rgba(0,0,0,0.00));
    }

    /* A-pillars (left/right frame) */
    .pillar {
      position:absolute; top:-4%; bottom: 18%;
      width: 18%;
      background: linear-gradient(to right,
        rgba(0,0,0,0.70),
        rgba(0,0,0,0.25),
        rgba(0,0,0,0.00));
      filter: blur(0.2px);
      opacity: 0.85;
    }
    .pillar.left {
      left:-4%;
      transform: skewX(-10deg);
      border-right: 1px solid rgba(255,255,255,0.06);
    }
    .pillar.right {
      right:-4%;
      transform: skewX(10deg) scaleX(-1);
      border-left: 1px solid rgba(255,255,255,0.06);
    }

    /* Glass subtle reflections */
    .glass-reflect {
      position:absolute; inset:0;
      background:
        radial-gradient(420px 300px at 70% 18%, rgba(255,255,255,0.05), transparent 60%),
        radial-gradient(520px 360px at 20% 22%, rgba(94,234,212,0.05), transparent 65%);
      mix-blend-mode: screen;
      opacity: 0.55;
    }

    /* Dashboard */
    .dash {
      position:absolute; left:-6%; right:-6%; bottom:-10%;
      height: 34%;
      background: radial-gradient(900px 300px at 50% 0%,
        rgba(255,255,255,0.08),
        rgba(255,255,255,0.00) 60%),
        linear-gradient(to bottom,
        rgba(10,14,20,0.00),
        rgba(6,8,12,0.75) 25%,
        rgba(6,8,12,0.92) 70%,
        rgba(6,8,12,0.98));
      border-top: 1px solid rgba(255,255,255,0.06);
      border-radius: 60% 60% 0 0;
      transform: translateY(6%);
    }

    /* Steering wheel (half) */
    .wheel-wrap{
      position:absolute;
      left:50%;
      bottom: 2.5%;
      width:min(320px, 72%);
      aspect-ratio: 1 / 1;
      transform: translateX(-50%);
      display:grid;
      place-items:center;
      opacity: 0.92;
    }
    .wheel{
      width:100%;
      height:100%;
      border-radius:999px;
      border: 18px solid rgba(30,36,46,0.92);
      box-shadow:
        0 20px 50px rgba(0,0,0,0.55),
        inset 0 0 0 2px rgba(255,255,255,0.06),
        inset 0 -10px 30px rgba(0,0,0,0.35);
      background: radial-gradient(circle at 50% 40%,
        rgba(255,255,255,0.06),
        rgba(0,0,0,0.10) 60%,
        rgba(0,0,0,0.20));
      /* Hide top half => only show lower half */
      clip-path: inset(52% 0 0 0 round 999px);
      transform: rotate(var(--wheelRot, 0deg));
      transition: transform 80ms linear;
    }
    .wheel:before{
      content:"";
      position:absolute;
      inset: 18%;
      border-radius:999px;
      border: 10px solid rgba(18,24,38,0.92);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.05);
    }
    .wheel:after{
      content:"";
      position:absolute;
      left:50%; top:50%;
      width: 22%;
      height: 22%;
      transform: translate(-50%,-50%);
      border-radius: 999px;
      background: radial-gradient(circle at 35% 35%,
        rgba(94,234,212,0.20),
        rgba(18,24,38,0.92));
      border: 1px solid rgba(255,255,255,0.07);
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
    }

    /* Overlay menu */
    .overlay{
      position:absolute;inset:0;display:grid;place-items:center;padding:18px;
      background:rgba(6,8,12,.56);backdrop-filter:blur(6px);
      opacity:0;pointer-events:none;transition:opacity .18s ease;z-index:20
    }
    .overlay.show{opacity:1;pointer-events:auto}
    .card{
      width:min(420px,100%);border-radius:16px;background:rgba(18,24,38,.92);
      border:1px solid rgba(255,255,255,.10);box-shadow:0 20px 60px rgba(0,0,0,.35);
      padding:16px;text-align:center
    }
    .card h1{margin:0 0 6px 0;font-size:18px;letter-spacing:.3px}
    .card p{margin:0 0 12px 0;color:var(--muted);font-size:13px;line-height:1.35}
    .hint{
      font-size:12px;color:rgba(231,238,252,.86);background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:10px 12px;text-align:left;margin:10px 0 14px 0
    }
    .hint kbd{
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:11px;
      padding:2px 6px;border-radius:8px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);
      margin:0 2px;white-space:nowrap
    }
    .card .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}

    .touch{
      position:fixed;left:0;right:0;bottom:max(10px, env(safe-area-inset-bottom));
      display:none;justify-content:center;gap:10px;padding:0 10px;pointer-events:none;z-index:9999
    }
    @media (max-width: 900px){ .touch{display:flex} }
    .touch button{
      pointer-events:auto;width:30%;max-width:220px;border-radius:14px;padding:14px 10px;font-size:14px;
      background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.18);color:var(--text);font-weight:800
    }
    .touch button.primary{background:rgba(94,234,212,.16);border-color:rgba(94,234,212,.28)}
    .touch button:active{transform:translateY(1px) scale(.99)}

    .footer{text-align:center;font-size:12px;color:rgba(155,176,209,.9);opacity:.9}

    @media (max-width: 520px){
      body{padding-bottom:96px}
      .wrap{padding:12px}
      .app{gap:10px}
      .topbar{padding:10px 10px;border-radius:14px;gap:8px}
      .title strong{font-size:14px}
      .title span{font-size:11px}
      .chip{padding:6px 8px;font-size:11px;gap:6px}
      .btn{padding:8px 10px;font-size:11px;border-radius:11px}
      .pillar{width:22%}
      .wheel{border-width:16px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="app">
      <div class="topbar" id="topbar">
        <div class="title">
          <strong>Mini Car Runner</strong>
          <span>Driver Seat POV · Windshield + steering</span>
        </div>

        <div class="stats">
          <div class="chip"><span class="dot"></span> <span>Score</span> <b id="score">0</b></div>
          <div class="chip"><span class="dot gray"></span> <span>Speed</span> <b id="speed">1.0</b></div>
          <div class="chip" id="levelChip" style="display:none"><span class="dot.purple"></span><span style="display:none"></span></div>
          <div class="chip" id="levelChip2" style="display:none"><span class="dot purple"></span> <span>Level</span> <b id="level">1</b></div>
          <div class="chip" id="bulletsChip" style="display:none"><span class="dot blue"></span> <span>Bullets</span> <b id="bullets">0</b></div>
          <div class="chip" id="livesChip" style="display:none"><span class="dot green"></span> <span>Life</span> <b id="lives">1</b></div>
          <button class="btn" id="soundBtn" type="button" title="Toggle sound">Sound: On</button>
          <button class="btn" id="pauseBtn" type="button">Pause</button>
          <button class="btn primary" id="restartBtn" type="button">Restart</button>
        </div>
      </div>

      <div class="stage" id="stage">
        <canvas id="game" width="540" height="960"></canvas>

        <!-- Driver POV overlays -->
        <div class="pov" aria-hidden="true">
          <div class="windshield-top"></div>
          <div class="pillar left"></div>
          <div class="pillar right"></div>
          <div class="glass-reflect"></div>
          <div class="dash"></div>
          <div class="wheel-wrap">
            <div class="wheel" id="wheel"></div>
          </div>
        </div>

        <div class="overlay show" id="overlay">
          <div class="card">
            <h1 id="overlayTitle">Choose Mode</h1>
            <p id="overlaySub">Pick a mode to start.</p>

            <div class="hint">
              Controls:
              <div style="margin-top:8px">
                <kbd>←</kbd>/<kbd>→</kbd> or <kbd>A</kbd>/<kbd>D</kbd> ·
                <kbd>F</kbd> shoot ·
                <kbd>Space</kbd> pause · <kbd>R</kbd> restart
              </div>
              <div style="margin-top:8px;opacity:.85" id="hintSub">
                On phone: use the fixed bottom Left/Right/Shoot buttons.
              </div>
            </div>

            <div class="row" id="modeRow">
              <button class="btn primary" id="modeInfiniteBtn" type="button">Infinite Shoot</button>
              <button class="btn" id="modeScarcityBtn" type="button">Scarcity</button>
            </div>

            <div class="row" id="levelRow" style="display:none">
              <button class="btn primary" id="lvl1Btn" type="button">Level 1 (Easy)</button>
              <button class="btn" id="lvl2Btn" type="button">Level 2 (Normal)</button>
              <button class="btn" id="lvl3Btn" type="button">Level 3 (Advanced)</button>
            </div>

            <div class="row" id="startRow" style="display:none">
              <button class="btn primary" id="startBtn" type="button">Start</button>
              <button class="btn" id="howBtn" type="button">How it works</button>
              <button class="btn" id="backBtn" type="button">Change Mode/Level</button>
            </div>
          </div>
        </div>
      </div>

      <div class="footer">
        Static single-file app — commit as <code>index.html</code>.
      </div>
    </div>
  </div>

  <div class="touch" id="touchControls">
    <button id="leftBtn" type="button">◀ Left</button>
    <button id="shootBtn" type="button" class="primary">● Shoot</button>
    <button id="rightBtn" type="button">Right ▶</button>
  </div>

  <script>
    (() => {
      // -----------------------------
      // Stage sizing
      // -----------------------------
      const stage = document.getElementById("stage");
      const topbar = document.getElementById("topbar");
      const wheelEl = document.getElementById("wheel");

      function computeStageHeight() {
        const vh = window.innerHeight || 800;
        const topH = topbar.getBoundingClientRect().height || 0;
        const wrapPad = 16 * 2;
        const gaps = 14 * 2;
        const touchH = (window.matchMedia("(max-width: 900px)").matches) ? 70 : 0;
        let h = vh - topH - wrapPad - gaps - touchH;
        h = Math.max(420, Math.min(h, 820));
        stage.style.setProperty("--stageH", h + "px");
      }
      window.addEventListener("resize", computeStageHeight);
      window.addEventListener("orientationchange", computeStageHeight);

      // -----------------------------
      // Canvas
      // -----------------------------
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const W = canvas.width;
      const H = canvas.height;

      // -----------------------------
      // UI
      // -----------------------------
      const scoreEl = document.getElementById("score");
      const speedEl = document.getElementById("speed");
      const levelChip = document.getElementById("levelChip2");
      const levelEl = document.getElementById("level");
      const bulletsChip = document.getElementById("bulletsChip");
      const bulletsEl = document.getElementById("bullets");
      const livesChip = document.getElementById("livesChip");
      const livesEl = document.getElementById("lives");
      const pauseBtn = document.getElementById("pauseBtn");
      const restartBtn = document.getElementById("restartBtn");
      const soundBtn = document.getElementById("soundBtn");

      const overlay = document.getElementById("overlay");
      const overlayTitle = document.getElementById("overlayTitle");
      const overlaySub = document.getElementById("overlaySub");
      const hintSub = document.getElementById("hintSub");

      const modeRow = document.getElementById("modeRow");
      const levelRow = document.getElementById("levelRow");
      const startRow = document.getElementById("startRow");

      const startBtn = document.getElementById("startBtn");
      const howBtn = document.getElementById("howBtn");
      const backBtn = document.getElementById("backBtn");

      const modeInfiniteBtn = document.getElementById("modeInfiniteBtn");
      const modeScarcityBtn = document.getElementById("modeScarcityBtn");
      const lvl1Btn = document.getElementById("lvl1Btn");
      const lvl2Btn = document.getElementById("lvl2Btn");
      const lvl3Btn = document.getElementById("lvl3Btn");

      const leftBtn = document.getElementById("leftBtn");
      const rightBtn = document.getElementById("rightBtn");
      const shootBtn = document.getElementById("shootBtn");

      // -----------------------------
      // Simple synth SFX
      // -----------------------------
      let soundOn = true;
      let audioCtx = null;
      function ensureAudio() {
        if (!soundOn) return null;
        if (!audioCtx) {
          const AC = window.AudioContext || window.webkitAudioContext;
          if (!AC) return null;
          audioCtx = new AC();
        }
        if (audioCtx.state === "suspended") audioCtx.resume().catch(() => {});
        return audioCtx;
      }
      function beep({freq=440, dur=0.08, type="sine", gain=0.06, sweep=0, when=0} = {}) {
        const ac = ensureAudio();
        if (!ac) return;
        const t0 = ac.currentTime + when;
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freq, t0);
        if (sweep) o.frequency.exponentialRampToValueAtTime(Math.max(30, freq + sweep), t0 + dur);
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
        o.connect(g); g.connect(ac.destination);
        o.start(t0); o.stop(t0 + dur + 0.02);
      }
      const SFX = {
        gainLife()    { beep({freq: 660, dur: 0.10, type:"sine", gain:0.07, sweep: +220}); beep({freq: 880, dur:0.08, type:"sine", gain:0.05, when:0.06}); },
        gainAmmo()    { beep({freq: 520, dur: 0.08, type:"triangle", gain:0.06, sweep:+120}); beep({freq: 740, dur:0.06, type:"triangle", gain:0.04, when:0.05}); },
        hitShot()     { beep({freq: 220, dur: 0.04, type:"square", gain:0.05, sweep:-40}); },
        destroyBox()  { beep({freq: 180, dur: 0.06, type:"sawtooth", gain:0.06, sweep:+220}); beep({freq: 110, dur: 0.08, type:"sawtooth", gain:0.05, when:0.03}); },
        hitObstacle() { beep({freq: 140, dur: 0.10, type:"square", gain:0.07, sweep:-60}); },
        carDies()     { beep({freq: 220, dur: 0.10, type:"sawtooth", gain:0.07, sweep:-140}); beep({freq: 120, dur: 0.18, type:"sawtooth", gain:0.06, when:0.08, sweep:-60}); },
      };
      function updateSoundBtn() {
        soundBtn.textContent = soundOn ? "Sound: On" : "Sound: Off";
        soundBtn.classList.toggle("warn", !soundOn);
      }

      // -----------------------------
      // Driver POV projection
      // -----------------------------
      const lanes = 3;
      const horizonY = Math.floor(H * 0.26);
      const roadBottomW = Math.floor(W * 0.74);
      const roadTopW    = Math.floor(W * 0.12);
      const roadCenterX = Math.floor(W * 0.5);
      const FOCAL = 320;

      function projYFromDist(d) {
        const t = FOCAL / (d + FOCAL);
        return horizonY + t * (H - horizonY);
      }
      function roadWidthAtY(y) {
        const t = (y - horizonY) / Math.max(1, (H - horizonY));
        return roadTopW + clamp(t, 0, 1) * (roadBottomW - roadTopW);
      }
      function laneCenterAt(laneIdx, y) {
        const rw = roadWidthAtY(y);
        const laneW = rw / lanes;
        const left = roadCenterX - rw/2;
        return left + laneW * laneIdx + laneW/2;
      }

      // -----------------------------
      // Car
      // -----------------------------
      const car = {
        lane: 1,
        x: roadCenterX,
        y: Math.floor(H * 0.82),
        w: 0,
        h: 0,
        color: "#5eead4",
      };
      function updateCarSize() {
        const rw = roadWidthAtY(car.y);
        const laneW = rw / lanes;
        car.w = Math.floor(laneW * 0.62);
        car.h = Math.floor(laneW * 1.08);
      }
      function resetCar() {
        car.lane = 1;
        car.x = Math.floor(laneCenterAt(car.lane, car.y));
      }

      // -----------------------------
      // Entities
      // -----------------------------
      const obstacles = [];
      const bullets = [];

      let mode = null;   // "infinite" | "scarcity"
      let level = null;  // 1 | 2 | 3

      let ammo = Infinity;
      let lives = 1;

      let invuln = 0;
      const INVULN_TIME = 0.65;

      let score = 0;
      let speedMul = 1.0;

      const obstacleKinds = [
        { name: "barrel", w: 0.55, h: 0.55, color: "#fbbf24" },
        { name: "cone",   w: 0.45, h: 0.65, color: "#fb7185" },
        { name: "block",  w: 0.78, h: 0.62, color: "#a78bfa" },
        { name: "oil",    w: 0.75, h: 0.35, color: "#94a3b8" },
      ];
      const ammoKind = { name: "ammo", w: 0.74, h: 0.56, color: "#60a5fa" };
      const lifeKind = { name: "life", w: 0.72, h: 0.54, color: "#34d399" };

      function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      function kindHP(kindName) {
        if (kindName === "cone") return 1;
        if (kindName === "barrel") return 2;
        if (kindName === "oil") return 2;
        if (kindName === "block") return 4;
        return 2;
      }

      function ammoValueBySpeed() {
        const hi = (speedMul < 1.7) ? 3 : (speedMul < 2.6) ? 4 : 5;
        return randInt(1, hi);
      }
      function lifeValueBySpeed() {
        const hi = (speedMul < 2.2) ? 2 : 3;
        return randInt(1, hi);
      }

      function obstaclePointsProjected(o) {
        const sizeTier = Math.max(1, Math.round((o.baseW * o.baseH) * 10));
        return 10 * sizeTier + 10 * (o.hpMax - 1);
      }

      const SPAWN_DIST = 1600;
      const DESPAWN_DIST = 70;

      function spawnThing() {
        const lane = randInt(0, lanes - 1);

        let kind = null;
        let isAmmo = false;
        let isLife = false;

        if (mode === "scarcity") {
          const ammoProb = clamp(0.14 + (speedMul - 1.0) * 0.03, 0.14, 0.22);
          if (Math.random() < ammoProb) { kind = ammoKind; isAmmo = true; }
        }

        if (!kind) {
          const lifeProb = clamp(0.06 + (speedMul - 1.0) * 0.01, 0.06, 0.10);
          if (Math.random() < lifeProb) { kind = lifeKind; isLife = true; }
        }

        if (!kind) kind = obstacleKinds[randInt(0, obstacleKinds.length - 1)];

        for (const o of obstacles) {
          if (o.lane === lane && Math.abs(o.d - SPAWN_DIST) < 180) return;
        }

        if (isAmmo) {
          const val = ammoValueBySpeed();
          obstacles.push({ lane, d: SPAWN_DIST, baseW: kind.w, baseH: kind.h, kind: "ammo", color: kind.color, isAmmo: true, isLife: false, value: val, hp: 1, hpMax: 1 });
          return;
        }
        if (isLife) {
          const val = lifeValueBySpeed();
          obstacles.push({ lane, d: SPAWN_DIST, baseW: kind.w, baseH: kind.h, kind: "life", color: kind.color, isAmmo: false, isLife: true, value: val, hp: 1, hpMax: 1 });
          return;
        }

        const hp0 = kindHP(kind.name);
        obstacles.push({ lane, d: SPAWN_DIST, baseW: kind.w, baseH: kind.h, kind: kind.name, color: kind.color, isAmmo: false, isLife: false, value: 0, hp: hp0, hpMax: hp0 });
      }

      // Dashes
      const dashMarks = [];
      function initDashes() {
        dashMarks.length = 0;
        const spacing = 140;
        const count = 28;
        for (let i = 0; i < count; i++) dashMarks.push({ d: i * spacing });
      }

      // Runtime flags
      let running = false;
      let paused = false;
      let crashed = false;
      let lastT = 0;

      // Spawning
      let spawnTimer = 0;
      let spawnEvery = 0.95;

      // Input holds
      let moveLeftHeld = false;
      let moveRightHeld = false;
      let laneMoveCooldown = 0;
      const laneMoveDelay = 0.12;

      let shootHeld = false;
      let shootCooldown = 0;
      const shootDelay = 0.14;
      let shootHeldTimer = 0;

      // Camera / wheel feel
      let camShiftX = 0;      // pixels shift of road center
      let camVel = 0;
      let wheelRot = 0;       // degrees

      function setOverlay(show, title, sub) {
        overlay.classList.toggle("show", !!show);
        if (title != null) overlayTitle.textContent = title;
        if (sub != null) overlaySub.textContent = sub;
      }

      function setUI() {
        scoreEl.textContent = String(Math.floor(score));
        speedEl.textContent = speedMul.toFixed(1);

        if (!mode || !level) {
          bulletsChip.style.display = "none";
          livesChip.style.display = "none";
          levelChip.style.display = "none";
        } else {
          bulletsChip.style.display = "inline-flex";
          livesChip.style.display = "inline-flex";
          levelChip.style.display = "inline-flex";
          bulletsEl.textContent = (mode === "scarcity") ? String(ammo) : "∞";
          livesEl.textContent = String(lives);
          levelEl.textContent = String(level);
        }

        pauseBtn.textContent = paused ? "Resume" : "Pause";
        updateSoundBtn();
      }

      function resetGame() {
        obstacles.length = 0;
        bullets.length = 0;
        score = 0;
        speedMul = 1.0;
        spawnTimer = 0;
        spawnEvery = 0.95;
        crashed = false;
        paused = false;
        laneMoveCooldown = 0;
        shootCooldown = 0;
        shootHeldTimer = 0;
        ammo = (mode === "scarcity") ? 0 : Infinity;
        lives = 1;
        invuln = 0;
        camShiftX = 0;
        camVel = 0;
        wheelRot = 0;
        resetCar();
        initDashes();
        setUI();
      }

      // Projected rect
      function projectedRectFor(o) {
        const y = projYFromDist(o.d);
        const rw = roadWidthAtY(y);
        const laneW = rw / lanes;
        const cx = (W*0.5 + camShiftX); // camera shift affects lane centers
        const left = cx - rw/2;
        const center = left + laneW * o.lane + laneW/2;

        const w = Math.max(10, Math.floor(laneW * o.baseW));
        const h = Math.max(10, Math.floor(laneW * o.baseH));
        return { x: Math.floor(center - w/2), y: Math.floor(y - h), w, h };
      }

      function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
        return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
      }

      // Drawing helpers
      function roundRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y, x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x, y + h, rr);
        ctx.arcTo(x, y + h, x, y, rr);
        ctx.arcTo(x, y, x + w, y, rr);
        ctx.closePath();
      }

      function drawRoadPOV() {
        const topW = roadTopW;
        const botW = roadBottomW;
        const topY = horizonY;
        const botY = H;

        const cx = W*0.5 + camShiftX;

        const leftTop = cx - topW/2;
        const rightTop = cx + topW/2;
        const leftBot = cx - botW/2;
        const rightBot = cx + botW/2;

        ctx.save();

        ctx.beginPath();
        ctx.moveTo(leftTop, topY);
        ctx.lineTo(rightTop, topY);
        ctx.lineTo(rightBot, botY);
        ctx.lineTo(leftBot, botY);
        ctx.closePath();

        const g = ctx.createLinearGradient(0, topY, 0, botY);
        g.addColorStop(0, "rgba(255,255,255,0.05)");
        g.addColorStop(1, "rgba(255,255,255,0.02)");
        ctx.fillStyle = g;
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,0.14)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // lane separators
        for (let li = 1; li < lanes; li++) {
          ctx.beginPath();
          const xTop = leftTop + (topW/lanes) * li;
          const xBot = leftBot + (botW/lanes) * li;
          ctx.moveTo(xTop, topY);
          ctx.lineTo(xBot, botY);
          ctx.strokeStyle = "rgba(255,255,255,0.10)";
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        // dashes
        ctx.beginPath();
        ctx.rect(0,0,W,H);
        ctx.clip();
        for (let li = 1; li < lanes; li++) {
          for (const d of dashMarks) {
            const y = projYFromDist(d.d);
            const nextY = projYFromDist(d.d + 70);
            const h = Math.max(6, Math.floor(nextY - y));
            if (y < horizonY || y > H) continue;

            const rw = roadWidthAtY(y);
            const laneW = rw / lanes;
            const left = cx - rw/2;
            const x = left + laneW * li;

            ctx.fillStyle = "rgba(255,255,255,0.18)";
            ctx.fillRect(x - 2, y, 4, h);
          }
        }

        ctx.restore();
      }

      function drawAmmoBox(o, r) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.33)";
        roundRect(ctx, r.x + 4, r.y + 6, r.w, r.h, 12); ctx.fill();
        ctx.fillStyle = o.color;
        roundRect(ctx, r.x, r.y, r.w, r.h, 12); ctx.fill();
        ctx.fillStyle = "rgba(8, 12, 18, 0.25)";
        roundRect(ctx, r.x + r.w*0.10, r.y + r.h*0.18, r.w*0.80, r.h*0.64, 10); ctx.fill();

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(231,238,252,0.95)";
        ctx.font = `900 ${Math.max(12, Math.floor(r.h*0.55))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText(String(o.value), r.x + r.w/2, r.y + r.h*0.52);

        ctx.fillStyle = "rgba(231,238,252,0.80)";
        ctx.font = `800 ${Math.max(9, Math.floor(r.h*0.20))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText("AMMO", r.x + r.w/2, r.y + r.h*0.82);
        ctx.restore();
      }

      function drawLifeBox(o, r) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.33)";
        roundRect(ctx, r.x + 4, r.y + 6, r.w, r.h, 12); ctx.fill();
        ctx.fillStyle = o.color;
        roundRect(ctx, r.x, r.y, r.w, r.h, 12); ctx.fill();
        ctx.fillStyle = "rgba(8, 12, 18, 0.22)";
        roundRect(ctx, r.x + r.w*0.10, r.y + r.h*0.18, r.w*0.80, r.h*0.64, 10); ctx.fill();

        ctx.fillStyle = "rgba(231,238,252,0.85)";
        ctx.beginPath();
        const cx = r.x + r.w*0.50, cy = r.y + r.h*0.34, rr = Math.min(r.w,r.h)*0.10;
        ctx.arc(cx - rr, cy, rr, 0, Math.PI*2);
        ctx.arc(cx + rr, cy, rr, 0, Math.PI*2);
        ctx.lineTo(cx, cy + rr*2.2);
        ctx.closePath();
        ctx.fill();

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(231,238,252,0.98)";
        ctx.font = `900 ${Math.max(12, Math.floor(r.h*0.55))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText(String(o.value), r.x + r.w/2, r.y + r.h*0.58);

        ctx.fillStyle = "rgba(231,238,252,0.80)";
        ctx.font = `800 ${Math.max(9, Math.floor(r.h*0.20))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText("LIFE", r.x + r.w/2, r.y + r.h*0.82);
        ctx.restore();
      }

      function drawObstacle(o, r) {
        if (o.isAmmo) return drawAmmoBox(o, r);
        if (o.isLife) return drawLifeBox(o, r);

        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.33)";
        roundRect(ctx, r.x + 4, r.y + 6, r.w, r.h, 12); ctx.fill();

        ctx.fillStyle = o.color;
        roundRect(ctx, r.x, r.y, r.w, r.h, 12); ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.16)";
        if (o.kind === "cone") {
          roundRect(ctx, r.x + r.w*0.18, r.y + r.h*0.35, r.w*0.64, r.h*0.10, 8); ctx.fill();
          roundRect(ctx, r.x + r.w*0.22, r.y + r.h*0.55, r.w*0.56, r.h*0.10, 8); ctx.fill();
        } else if (o.kind === "barrel") {
          roundRect(ctx, r.x + r.w*0.10, r.y + r.h*0.18, r.w*0.80, r.h*0.10, 8); ctx.fill();
          roundRect(ctx, r.x + r.w*0.10, r.y + r.h*0.72, r.w*0.80, r.h*0.10, 8); ctx.fill();
        } else if (o.kind === "oil") {
          roundRect(ctx, r.x + r.w*0.12, r.y + r.h*0.22, r.w*0.76, r.h*0.56, 999); ctx.fill();
        } else {
          roundRect(ctx, r.x + r.w*0.14, r.y + r.h*0.20, r.w*0.72, r.h*0.60, 10); ctx.fill();
        }

        if (o.hpMax > 1) {
          const pad = Math.max(5, Math.floor(r.w*0.10));
          const barW = r.w - pad*2;
          const barH = Math.max(4, Math.floor(r.h*0.10));
          const bx = r.x + pad;
          const by = r.y + Math.max(4, Math.floor(r.h*0.08));
          ctx.fillStyle = "rgba(0,0,0,0.35)";
          roundRect(ctx, bx, by, barW, barH, 4); ctx.fill();
          const frac = clamp(o.hp / o.hpMax, 0, 1);
          ctx.fillStyle = "rgba(231,238,252,0.65)";
          roundRect(ctx, bx, by, barW * frac, barH, 4); ctx.fill();
        }

        ctx.restore();
      }

      function drawBullet(b) {
        const y = projYFromDist(b.d);
        const rw = roadWidthAtY(y);
        const laneW = rw / lanes;
        const cx = (W*0.5 + camShiftX);
        const left = cx - rw/2;
        const c = left + laneW * b.lane + laneW/2;

        const w = Math.max(5, Math.floor(laneW * 0.10));
        const h = Math.max(10, Math.floor(laneW * 0.22));
        const x = Math.floor(c - w/2);
        const yy = Math.floor(y - h);

        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(231,238,252,0.9)";
        roundRect(ctx, x, yy, w, h, 8); ctx.fill();
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = "rgba(94,234,212,0.7)";
        roundRect(ctx, x + 2, yy + h*0.25, w - 4, h*0.5, 6); ctx.fill();
        ctx.restore();

        b._rect = { x, y: yy, w, h };
      }

      function drawCar() {
        updateCarSize();

        // car slightly shifts with camera for “in-cabin” feel
        const laneX = laneCenterAt(car.lane, car.y);
        car.x = Math.floor(laneX + camShiftX * 0.25);

        const x = car.x - car.w/2;
        const y = car.y - car.h;

        ctx.save();
        if (invuln > 0) ctx.globalAlpha = 0.55 + 0.45 * Math.sin(performance.now() * 0.02);

        ctx.fillStyle = "rgba(0,0,0,0.35)";
        roundRect(ctx, x + 6, y + 10, car.w, car.h, 16); ctx.fill();

        ctx.fillStyle = car.color;
        roundRect(ctx, x, y, car.w, car.h, 16); ctx.fill();

        ctx.fillStyle = "rgba(8, 12, 18, 0.55)";
        roundRect(ctx, x + car.w*0.18, y + car.h*0.18, car.w*0.64, car.h*0.26, 12); ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.18)";
        roundRect(ctx, x + car.w*0.45, y + car.h*0.12, car.w*0.10, car.h*0.72, 10); ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.75)";
        roundRect(ctx, x + car.w*0.12, y + car.h*0.06, car.w*0.18, car.h*0.08, 8); ctx.fill();
        roundRect(ctx, x + car.w*0.70, y + car.h*0.06, car.w*0.18, car.h*0.08, 8); ctx.fill();

        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(x - 6, y + car.h*0.20, 8, car.h*0.22);
        ctx.fillRect(x - 6, y + car.h*0.58, 8, car.h*0.22);
        ctx.fillRect(x + car.w - 2, y + car.h*0.20, 8, car.h*0.22);
        ctx.fillRect(x + car.w - 2, y + car.h*0.58, 8, car.h*0.22);

        ctx.restore();

        car._rect = { x, y, w: car.w, h: car.h };
      }

      function render() {
        ctx.clearRect(0,0,W,H);

        drawRoadPOV();

        const sortedObs = obstacles.slice().sort((a,b)=> b.d - a.d);
        for (const o of sortedObs) {
          const r = projectedRectFor(o);
          o._rect = r;
          drawObstacle(o, r);
        }

        const sortedBul = bullets.slice().sort((a,b)=> b.d - a.d);
        for (const b of sortedBul) drawBullet(b);

        drawCar();

        if (!running) return;

        if (paused) {
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.35)";
          ctx.fillRect(0,0,W,H);
          ctx.fillStyle = "rgba(231,238,252,0.92)";
          ctx.font = "800 34px system-ui, -apple-system, Segoe UI, Roboto, Arial";
          ctx.textAlign = "center";
          ctx.fillText("PAUSED", W/2, H/2);
          ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
          ctx.fillStyle = "rgba(231,238,252,0.75)";
          ctx.fillText("Tap Resume / press Space", W/2, H/2 + 28);
          ctx.restore();
        }
      }

      // -----------------------------
      // Gameplay
      // -----------------------------
      function tryMove(dir) {
        const next = clamp(car.lane + dir, 0, lanes - 1);
        if (next !== car.lane) {
          car.lane = next;
          laneMoveCooldown = laneMoveDelay;

          // camera + wheel feedback
          camVel += dir * 520;
        }
      }

      function grantAmmo(units) {
        if (mode !== "scarcity") return;
        ammo += units * 10;
        setUI();
        SFX.gainAmmo();
      }

      function grantLife(n) {
        lives += n;
        setUI();
        SFX.gainLife();
      }

      function spendLife() {
        if (invuln > 0) return;
        lives -= 1;
        invuln = INVULN_TIME;
        setUI();
        SFX.hitObstacle();
        if (lives <= 0) die();
      }

      function die() {
        crashed = true;
        paused = false;
        running = false;
        SFX.carDies();
        setOverlay(true, "Car Died!", `Final score: ${Math.floor(score)}. Tap Start or press R.`);
        modeRow.style.display = "none";
        levelRow.style.display = "none";
        startRow.style.display = "flex";
      }

      function shootOnce() {
        if (!running || paused || crashed) return;
        if (!mode || !level) return;
        if (shootCooldown > 0) return;

        if (mode === "scarcity") {
          if (ammo <= 0) return;
          ammo -= 1;
        }

        shootCooldown = 0.14;
        bullets.push({ lane: car.lane, d: 50 });
        setUI();
      }

      function update(dt) {
        speedMul += dt * 0.03;
        speedMul = Math.min(speedMul, 4.0);

        const speed = 620 * speedMul;

        invuln = Math.max(0, invuln - dt);

        spawnEvery = clamp(0.95 - (speedMul - 1.0) * 0.15, 0.35, 0.95);

        laneMoveCooldown = Math.max(0, laneMoveCooldown - dt);
        if (laneMoveCooldown <= 0) {
          if (moveLeftHeld) tryMove(-1);
          else if (moveRightHeld) tryMove(+1);
        }

        // steering wheel + camera sway dynamics
        camShiftX += camVel * dt;
        camVel *= Math.pow(0.001, dt);
        camShiftX *= Math.pow(0.001, dt); // recenter
        camShiftX = clamp(camShiftX, -40, 40);

        wheelRot += ((camShiftX * 0.65) - wheelRot) * (1 - Math.pow(0.001, dt));
        if (wheelEl) wheelEl.style.setProperty("--wheelRot", `${wheelRot}deg`);

        shootCooldown = Math.max(0, shootCooldown - dt);
        if (shootHeld) {
          shootHeldTimer += dt;
          if (shootHeldTimer >= 0.14) {
            shootHeldTimer = 0;
            shootOnce();
          }
        } else shootHeldTimer = 0;

        for (const dm of dashMarks) dm.d -= speed * dt * 0.80;
        for (const dm of dashMarks) if (dm.d < 0) dm.d += 140 * 28;

        spawnTimer += dt;
        while (spawnTimer >= spawnEvery) {
          spawnTimer -= spawnEvery;
          spawnThing();
          if (speedMul > 2.0 && Math.random() < 0.25) spawnThing();
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
          obstacles[i].d -= speed * dt;
          if (obstacles[i].d < -DESPAWN_DIST) obstacles.splice(i, 1);
        }

        const bulletSpeed = 1400;
        for (let i = bullets.length - 1; i >= 0; i--) {
          bullets[i].d += bulletSpeed * dt;
          if (bullets[i].d > SPAWN_DIST + 200) bullets.splice(i, 1);
        }

        for (const o of obstacles) o._rect = projectedRectFor(o);

        for (const b of bullets) {
          const y = projYFromDist(b.d);
          const rw = roadWidthAtY(y);
          const laneW = rw / lanes;
          const cx = (W*0.5 + camShiftX);
          const left = cx - rw/2;
          const c = left + laneW * b.lane + laneW/2;
          const w = Math.max(5, Math.floor(laneW * 0.10));
          const h = Math.max(10, Math.floor(laneW * 0.22));
          b._rect = { x: Math.floor(c - w/2), y: Math.floor(y - h), w, h };
        }

        // bullet vs obstacles
        for (let bi = bullets.length - 1; bi >= 0; bi--) {
          const b = bullets[bi];
          let hit = false;

          for (let oi = obstacles.length - 1; oi >= 0; oi--) {
            const o = obstacles[oi];
            if (!aabb(b._rect.x, b._rect.y, b._rect.w, b._rect.h, o._rect.x, o._rect.y, o._rect.w, o._rect.h)) continue;
            hit = true;

            if (o.isLife) {
              if (level === 1) {
                SFX.hitShot();
              } else if (level === 2) {
                obstacles.splice(oi, 1);
                SFX.hitShot();
              } else {
                obstacles.splice(oi, 1);
                lives -= o.value;
                setUI();
                SFX.hitObstacle();
                if (lives <= 0) die();
              }
              break;
            }

            if (o.isAmmo) {
              if (mode === "scarcity") grantAmmo(o.value);
              obstacles.splice(oi, 1);
              break;
            }

            o.hp -= 1;
            SFX.hitShot();
            if (o.hp <= 0) {
              score += obstaclePointsProjected(o);
              obstacles.splice(oi, 1);
              SFX.destroyBox();
            }
            break;
          }

          if (hit) bullets.splice(bi, 1);
        }

        // car collision near
        const cr = car._rect || { x:0,y:0,w:0,h:0 };
        for (let oi = obstacles.length - 1; oi >= 0; oi--) {
          const o = obstacles[oi];
          if (o.d > 220) continue;
          if (!aabb(cr.x, cr.y, cr.w, cr.h, o._rect.x, o._rect.y, o._rect.w, o._rect.h)) continue;

          if (o.isLife) { grantLife(o.value); obstacles.splice(oi, 1); continue; }
          if (o.isAmmo) { if (mode === "scarcity") grantAmmo(o.value); obstacles.splice(oi, 1); continue; }

          if (invuln <= 0) {
            obstacles.splice(oi, 1);
            spendLife();
          }
          break;
        }

        setUI();
      }

      function step(t) {
        requestAnimationFrame(step);
        if (!running) { render(); lastT = t; return; }
        const dt = Math.min(0.033, (t - lastT) / 1000 || 0);
        lastT = t;
        if (paused || crashed) { render(); return; }
        update(dt);
        render();
      }

      function start() {
        if (!mode || !level) return;
        running = true;
        paused = false;
        crashed = false;
        setOverlay(false);
        lastT = performance.now();
        setUI();
      }

      function togglePause() {
        if (!running || crashed) return;
        paused = !paused;
        setUI();
      }

      function startOrRestart() {
        if (!mode || !level) return;
        resetGame();
        start();
      }

      // Input
      function onKeyDown(e) {
        if (e.repeat) return;
        const k = e.key.toLowerCase();
        if (k === "arrowleft" || k === "a") { moveLeftHeld = true; e.preventDefault(); ensureAudio(); }
        else if (k === "arrowright" || k === "d") { moveRightHeld = true; e.preventDefault(); ensureAudio(); }
        else if (k === "f") { ensureAudio(); shootOnce(); e.preventDefault(); }
        else if (k === " " || k === "spacebar") { ensureAudio(); togglePause(); e.preventDefault(); }
        else if (k === "r") { ensureAudio(); startOrRestart(); e.preventDefault(); }
      }
      function onKeyUp(e) {
        const k = e.key.toLowerCase();
        if (k === "arrowleft" || k === "a") moveLeftHeld = false;
        if (k === "arrowright" || k === "d") moveRightHeld = false;
      }

      function bindTouchHold(btn, setter) {
        btn.addEventListener("touchstart", (e) => { setter(true); e.preventDefault(); ensureAudio(); }, { passive: false });
        btn.addEventListener("touchend",   (e) => { setter(false); e.preventDefault(); }, { passive: false });
        btn.addEventListener("touchcancel",() => setter(false));
        btn.addEventListener("pointerdown", (e) => { setter(true); e.preventDefault(); ensureAudio(); });
        btn.addEventListener("pointerup",   (e) => { setter(false); e.preventDefault(); });
        btn.addEventListener("pointercancel", () => setter(false));
        btn.addEventListener("pointerleave",  () => setter(false));
      }

      // Overlay selection
      function showModePicker() {
        mode = null; level = null;
        running = false; paused = false; crashed = false;

        modeRow.style.display = "flex";
        levelRow.style.display = "none";
        startRow.style.display = "none";

        setOverlay(true, "Choose Mode", "Pick a mode to start.");
        hintSub.textContent = "On phone: use the fixed bottom Left/Right/Shoot buttons.";

        setUI();
        computeStageHeight();
      }

      function chooseMode(nextMode) {
        mode = nextMode;
        level = null;

        modeRow.style.display = "none";
        levelRow.style.display = "flex";
        startRow.style.display = "none";

        if (mode === "infinite") {
          setOverlay(true, "Choose Level", "Infinite Shoot: unlimited bullets. Select Level 1/2/3.");
        } else {
          setOverlay(true, "Choose Level", "Scarcity: start with 0 bullets. Collect AMMO. Select Level 1/2/3.");
        }

        setUI();
        computeStageHeight();
      }

      function chooseLevel(nextLevel) {
        level = nextLevel;

        levelRow.style.display = "none";
        startRow.style.display = "flex";

        let lvTxt = "";
        if (level === 1) lvTxt = "Level 1 (Easy): shooting LIFE box has no effect.";
        if (level === 2) lvTxt = "Level 2 (Normal): shooting LIFE box destroys it, no life change.";
        if (level === 3) lvTxt = "Level 3 (Advanced): shooting LIFE box reduces life by its number.";

        setOverlay(true, "Ready!", `${lvTxt} Tap Start (or tap the game area).`);

        resetGame();
        computeStageHeight();
      }

      // UI bindings
      pauseBtn.addEventListener("click", () => { ensureAudio(); togglePause(); });
      restartBtn.addEventListener("click", () => { ensureAudio(); startOrRestart(); });
      startBtn.addEventListener("click", () => { ensureAudio(); startOrRestart(); });

      modeInfiniteBtn.addEventListener("click", () => { ensureAudio(); chooseMode("infinite"); });
      modeScarcityBtn.addEventListener("click", () => { ensureAudio(); chooseMode("scarcity"); });

      lvl1Btn.addEventListener("click", () => { ensureAudio(); chooseLevel(1); });
      lvl2Btn.addEventListener("click", () => { ensureAudio(); chooseLevel(2); });
      lvl3Btn.addEventListener("click", () => { ensureAudio(); chooseLevel(3); });

      backBtn.addEventListener("click", () => { ensureAudio(); showModePicker(); });

      howBtn.addEventListener("click", () => {
        const modeTxt =
          (mode === "infinite")
            ? "Mode: Infinite Shoot\n• Bullets are unlimited (∞)."
            : "Mode: Scarcity\n• You start with 0 bullets.\n• AMMO boxes (blue): number is in tens (1=10,2=20,...).\n• Hit or shoot AMMO to gain bullets.\n• Shooting costs 1 bullet.";
        const lvlTxt =
          (level === 1) ? "Level 1: shooting LIFE box has no effect."
          : (level === 2) ? "Level 2: shooting LIFE box destroys it, no life change."
          : "Level 3: shooting LIFE box reduces life by its number.";
        alert("Driver Seat POV:\n• Windshield + dashboard overlays.\n• Steering wheel turns a bit when changing lane.\n\n" + modeTxt + "\n\nCommon:\n• 3 lanes.\n• Only destroying obstacle boxes gives points.\n• LIFE boxes (green): hitting adds life.\n" + lvlTxt);
      });

      soundBtn.addEventListener("click", () => { ensureAudio(); soundOn = !soundOn; setUI(); });

      bindTouchHold(leftBtn,  (v) => { moveLeftHeld = v; if (v) moveRightHeld = false; });
      bindTouchHold(rightBtn, (v) => { moveRightHeld = v; if (v) moveLeftHeld = false; });
      bindTouchHold(shootBtn, (v) => { shootHeld = v; if (v) shootOnce(); });

      document.getElementById("stage").addEventListener("pointerdown", () => {
        if (!mode || !level) return;
        ensureAudio();
        if (!running) startOrRestart();
      });

      window.addEventListener("keydown", onKeyDown, { passive: false });
      window.addEventListener("keyup", onKeyUp);

      // Init
      updateSoundBtn();
      initDashes();
      resetCar();
      computeStageHeight();
      showModePicker();
      requestAnimationFrame(step);

      setTimeout(computeStageHeight, 50);
      setTimeout(computeStageHeight, 250);
    })();
  </script>
</body>
</html>