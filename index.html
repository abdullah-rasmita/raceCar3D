<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Car Runner — Cockpit POV</title>
  <style>
    :root{
      --bg:#0b0f14;--panel:#121826;--text:#e7eefc;--muted:#9bb0d1;--accent:#5eead4;--shadow:rgba(0,0,0,.35)
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:radial-gradient(1200px 800px at 70% 10%, #182033 0%, var(--bg) 55%);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      padding-bottom:104px;
      overflow-x:hidden;
    }
    .wrap{min-height:100%;display:grid;place-items:center;padding:16px}
    .app{width:min(920px,100%);display:grid;grid-template-columns:1fr;gap:14px;align-items:start}

    .topbar{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      padding:12px 14px;border-radius:16px;background:rgba(18,24,38,.88);
      box-shadow:0 10px 30px var(--shadow);border:1px solid rgba(255,255,255,.08);
      flex-wrap:wrap;
    }
    .title{display:flex;flex-direction:column;gap:2px;line-height:1.1;min-width:180px}
    .title strong{font-size:15px;letter-spacing:.3px}
    .title span{font-size:12px;color:var(--muted)}
    .stats{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end}

    .chip{
      display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:999px;
      background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);
      font-size:12px;user-select:none;white-space:nowrap
    }
    .chip b{font-variant-numeric:tabular-nums}
    .dot{width:8px;height:8px;border-radius:999px;background:var(--accent);box-shadow:0 0 0 4px rgba(94,234,212,.12)}
    .dot.gray{background:rgba(255,255,255,.35);box-shadow:0 0 0 4px rgba(255,255,255,.06)}
    .dot.blue{background:#60a5fa;box-shadow:0 0 0 4px rgba(96,165,250,.12)}
    .dot.green{background:#34d399;box-shadow:0 0 0 4px rgba(52,211,153,.12)}
    .dot.purple{background:#a78bfa;box-shadow:0 0 0 4px rgba(167,139,250,.12)}

    .btn{
      appearance:none;border:0;border-radius:12px;padding:10px 12px;color:var(--text);
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10);
      cursor:pointer;font-weight:700;font-size:12px;letter-spacing:.2px;
      transition:transform .08s ease, background .2s ease, border-color .2s ease;user-select:none
    }
    .btn:hover{background:rgba(255,255,255,.11)}
    .btn:active{transform:translateY(1px) scale(.99)}
    .btn.primary{background:rgba(94,234,212,.14);border-color:rgba(94,234,212,.24)}
    .btn.primary:hover{background:rgba(94,234,212,.18)}
    .btn.warn{background:rgba(251,113,133,.14);border-color:rgba(251,113,133,.24)}
    .btn.warn:hover{background:rgba(251,113,133,.18)}

    .stage{
      position:relative;
      width:min(520px,100%);
      margin:0 auto;
      border-radius:18px;
      overflow:hidden;
      background:linear-gradient(#0c1220,#0a0f1a);
      border:1px solid rgba(255,255,255,.10);
      box-shadow:0 20px 60px var(--shadow);
      height: var(--stageH, 72vh);
      max-height: 820px;
      min-height: 420px;
      touch-action:none;
    }
    canvas{
      display:block;
      width:100%;
      height:100%;
      background:
        radial-gradient(900px 600px at 50% -20%, rgba(94,234,212,.08) 0%, transparent 55%),
        linear-gradient(#0a1020,#070b12);
    }

    .overlay{
      position:absolute;inset:0;display:grid;place-items:center;padding:18px;
      background:rgba(6,8,12,.56);backdrop-filter:blur(6px);
      opacity:0;pointer-events:none;transition:opacity .18s ease;z-index:20
    }
    .overlay.show{opacity:1;pointer-events:auto}
    .card{
      width:min(420px,100%);border-radius:16px;background:rgba(18,24,38,.92);
      border:1px solid rgba(255,255,255,.10);box-shadow:0 20px 60px rgba(0,0,0,.35);
      padding:16px;text-align:center
    }
    .card h1{margin:0 0 6px 0;font-size:18px;letter-spacing:.3px}
    .card p{margin:0 0 12px 0;color:var(--muted);font-size:13px;line-height:1.35}
    .hint{
      font-size:12px;color:rgba(231,238,252,.86);background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:10px 12px;text-align:left;margin:10px 0 14px 0
    }
    .hint kbd{
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:11px;
      padding:2px 6px;border-radius:8px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);
      margin:0 2px;white-space:nowrap
    }
    .card .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}

    .touch{
      position:fixed;left:0;right:0;bottom:max(10px, env(safe-area-inset-bottom));
      display:none;justify-content:center;gap:10px;padding:0 10px;pointer-events:none;z-index:9999
    }
    @media (max-width: 900px){ .touch{display:flex} }
    .touch button{
      pointer-events:auto;width:30%;max-width:220px;border-radius:14px;padding:14px 10px;font-size:14px;
      background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.18);color:var(--text);font-weight:800
    }
    .touch button.primary{background:rgba(94,234,212,.16);border-color:rgba(94,234,212,.28)}
    .touch button:active{transform:translateY(1px) scale(.99)}

    .footer{text-align:center;font-size:12px;color:rgba(155,176,209,.9);opacity:.9}

    @media (max-width: 520px){
      body{padding-bottom:96px}
      .wrap{padding:12px}
      .app{gap:10px}
      .topbar{padding:10px 10px;border-radius:14px;gap:8px}
      .title strong{font-size:14px}
      .title span{font-size:11px}
      .chip{padding:6px 8px;font-size:11px;gap:6px}
      .btn{padding:8px 10px;font-size:11px;border-radius:11px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="app">
      <div class="topbar" id="topbar">
        <div class="title">
          <strong>Mini Car Runner</strong>
          <span>Cockpit POV · Steering + windshield</span>
        </div>

        <div class="stats">
          <div class="chip"><span class="dot"></span> <span>Score</span> <b id="score">0</b></div>
          <div class="chip"><span class="dot gray"></span> <span>Speed</span> <b id="speed">1.0</b></div>
          <div class="chip"><span class="dot purple"></span> <span>Level</span> <b id="level">1</b></div>
          <div class="chip"><span class="dot blue"></span> <span>Bullets</span> <b id="bullets">∞</b></div>
          <div class="chip"><span class="dot green"></span> <span>Life</span> <b id="lives">1</b></div>
          <button class="btn" id="soundBtn" type="button">Sound: On</button>
          <button class="btn" id="pauseBtn" type="button">Pause</button>
          <button class="btn primary" id="restartBtn" type="button">Restart</button>
        </div>
      </div>

      <div class="stage" id="stage">
        <canvas id="game" width="540" height="960"></canvas>

        <div class="overlay show" id="overlay">
          <div class="card">
            <h1 id="overlayTitle">Choose Mode</h1>
            <p id="overlaySub">Pick a mode to start.</p>

            <div class="hint">
              Controls:
              <div style="margin-top:8px">
                <kbd>←</kbd>/<kbd>→</kbd> or <kbd>A</kbd>/<kbd>D</kbd> ·
                <kbd>F</kbd> shoot ·
                <kbd>Space</kbd> pause · <kbd>R</kbd> restart
              </div>
              <div style="margin-top:8px;opacity:.85" id="hintSub">
                On phone: use the fixed bottom Left/Shoot/Right buttons.
              </div>
            </div>

            <div class="row" id="modeRow">
              <button class="btn primary" id="modeInfiniteBtn" type="button">Infinite Shoot</button>
              <button class="btn" id="modeScarcityBtn" type="button">Scarcity</button>
            </div>

            <div class="row" id="levelRow" style="display:none">
              <button class="btn primary" id="lvl1Btn" type="button">Level 1 (Easy)</button>
              <button class="btn" id="lvl2Btn" type="button">Level 2 (Normal)</button>
              <button class="btn" id="lvl3Btn" type="button">Level 3 (Advanced)</button>
            </div>

            <div class="row" id="startRow" style="display:none">
              <button class="btn primary" id="startBtn" type="button">Start</button>
              <button class="btn" id="howBtn" type="button">How it works</button>
              <button class="btn" id="backBtn" type="button">Change Mode/Level</button>
            </div>
          </div>
        </div>
      </div>

      <div class="footer">
        Static single-file app — commit as <code>index.html</code>.
      </div>
    </div>
  </div>

  <div class="touch" id="touchControls">
    <button id="leftBtn" type="button">◀ Left</button>
    <button id="shootBtn" type="button" class="primary">● Shoot</button>
    <button id="rightBtn" type="button">Right ▶</button>
  </div>

  <script>
    (() => {
      // -----------------------------
      // Stage sizing
      // -----------------------------
      const stage = document.getElementById("stage");
      const topbar = document.getElementById("topbar");

      function computeStageHeight() {
        const vh = window.innerHeight || 800;
        const topH = topbar.getBoundingClientRect().height || 0;
        const wrapPad = 16 * 2;
        const gaps = 14 * 2;
        const touchH = (window.matchMedia("(max-width: 900px)").matches) ? 70 : 0;
        let h = vh - topH - wrapPad - gaps - touchH;
        h = Math.max(420, Math.min(h, 820));
        stage.style.setProperty("--stageH", h + "px");
      }
      window.addEventListener("resize", computeStageHeight);
      window.addEventListener("orientationchange", computeStageHeight);

      // -----------------------------
      // Canvas
      // -----------------------------
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const W = canvas.width;
      const H = canvas.height;

      // -----------------------------
      // UI
      // -----------------------------
      const scoreEl = document.getElementById("score");
      const speedEl = document.getElementById("speed");
      const levelEl = document.getElementById("level");
      const bulletsEl = document.getElementById("bullets");
      const livesEl = document.getElementById("lives");
      const pauseBtn = document.getElementById("pauseBtn");
      const restartBtn = document.getElementById("restartBtn");
      const soundBtn = document.getElementById("soundBtn");

      const overlay = document.getElementById("overlay");
      const overlayTitle = document.getElementById("overlayTitle");
      const overlaySub = document.getElementById("overlaySub");
      const hintSub = document.getElementById("hintSub");

      const modeRow = document.getElementById("modeRow");
      const levelRow = document.getElementById("levelRow");
      const startRow = document.getElementById("startRow");

      const startBtn = document.getElementById("startBtn");
      const howBtn = document.getElementById("howBtn");
      const backBtn = document.getElementById("backBtn");

      const modeInfiniteBtn = document.getElementById("modeInfiniteBtn");
      const modeScarcityBtn = document.getElementById("modeScarcityBtn");
      const lvl1Btn = document.getElementById("lvl1Btn");
      const lvl2Btn = document.getElementById("lvl2Btn");
      const lvl3Btn = document.getElementById("lvl3Btn");

      const leftBtn = document.getElementById("leftBtn");
      const rightBtn = document.getElementById("rightBtn");
      const shootBtn = document.getElementById("shootBtn");

      // -----------------------------
      // Simple synth SFX
      // -----------------------------
      let soundOn = true;
      let audioCtx = null;
      function ensureAudio() {
        if (!soundOn) return null;
        if (!audioCtx) {
          const AC = window.AudioContext || window.webkitAudioContext;
          if (!AC) return null;
          audioCtx = new AC();
        }
        if (audioCtx.state === "suspended") audioCtx.resume().catch(() => {});
        return audioCtx;
      }
      function beep({freq=440, dur=0.08, type="sine", gain=0.06, sweep=0, when=0} = {}) {
        const ac = ensureAudio();
        if (!ac) return;
        const t0 = ac.currentTime + when;
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freq, t0);
        if (sweep) o.frequency.exponentialRampToValueAtTime(Math.max(30, freq + sweep), t0 + dur);
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
        o.connect(g); g.connect(ac.destination);
        o.start(t0); o.stop(t0 + dur + 0.02);
      }
      const SFX = {
        gainLife()    { beep({freq: 660, dur: 0.10, type:"sine", gain:0.07, sweep: +220}); beep({freq: 880, dur:0.08, type:"sine", gain:0.05, when:0.06}); },
        gainAmmo()    { beep({freq: 520, dur: 0.08, type:"triangle", gain:0.06, sweep:+120}); beep({freq: 740, dur:0.06, type:"triangle", gain:0.04, when:0.05}); },
        shoot()       { beep({freq: 260, dur: 0.04, type:"square", gain:0.05, sweep:+40}); },
        hitShot()     { beep({freq: 220, dur: 0.04, type:"square", gain:0.05, sweep:-40}); },
        destroyBox()  { beep({freq: 180, dur: 0.06, type:"sawtooth", gain:0.06, sweep:+220}); beep({freq: 110, dur: 0.08, type:"sawtooth", gain:0.05, when:0.03}); },
        hitObstacle() { beep({freq: 140, dur: 0.10, type:"square", gain:0.07, sweep:-60}); },
        carDies()     { beep({freq: 220, dur: 0.10, type:"sawtooth", gain:0.07, sweep:-140}); beep({freq: 120, dur: 0.18, type:"sawtooth", gain:0.06, when:0.08, sweep:-60}); },
      };
      function updateSoundBtn() {
        soundBtn.textContent = soundOn ? "Sound: On" : "Sound: Off";
        soundBtn.classList.toggle("warn", !soundOn);
      }

      // -----------------------------
      // Helpers
      // -----------------------------
      function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      function roundRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y, x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x, y + h, rr);
        ctx.arcTo(x, y + h, x, y, rr);
        ctx.arcTo(x, y, x + w, y, rr);
        ctx.closePath();
      }

      function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
        return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
      }

      // -----------------------------
      // GAME STATE
      // -----------------------------
      let mode = null;   // "infinite" | "scarcity"
      let level = null;  // 1,2,3

      let running = false;
      let paused = false;
      let crashed = false;

      let score = 0;
      let speedMul = 1.0;

      let ammo = Infinity;
      let lives = 1;

      let invuln = 0;
      const INVULN_TIME = 0.65;

      // PLAYER lane
      const lanes = 3;
      let playerLane = 1;

      // --- IMPORTANT FIX ---
      // Camera lane centering must depend on Y (because lane width changes with Y).
      // We compute camShiftAtY(y): how much to shift road center at that y so that
      // the chosen lane center lands exactly at screen center.
      let camSwayX = 0;
      let camSwayVel = 0;

      // steering wheel
      let wheelRot = 0;

      // POV / projection
      const horizonY = Math.floor(H * 0.18);

      // road perspective
      const roadBottomW = Math.floor(W * 1.20);
      const roadTopW    = Math.floor(W * 0.10);
      const FOCAL = 300;

      function projYFromDist(d) {
        const t = FOCAL / (d + FOCAL);
        return horizonY + t * (H - horizonY);
      }
      function roadWidthAtY(y) {
        const t = (y - horizonY) / Math.max(1, (H - horizonY));
        return roadTopW + clamp(t, 0, 1) * (roadBottomW - roadTopW);
      }

      function camShiftAtY(y) {
        // Solve for camX in:
        // laneCenter = (W/2 + camX - rw/2) + (rw/lanes)*(lane+0.5) = W/2
        // => camX = rw/2 - rw*(lane+0.5)/lanes = rw*(0.5 - (lane+0.5)/lanes)
        const rw = roadWidthAtY(y);
        const base = rw * (0.5 - (playerLane + 0.5) / lanes);

        // sway should be stronger near bottom than near horizon (feels natural)
        const t = clamp((y - horizonY) / Math.max(1, (H - horizonY)), 0, 1);
        const sway = camSwayX * (0.20 + 0.80 * t);

        return base + sway;
      }

      // cockpit collision
      const COLLIDE_D = 140;

      // -----------------------------
      // Entities
      // -----------------------------
      const obstacles = [];
      const bullets = [];

      const obstacleKinds = [
        { name: "barrel", w: 0.55, h: 0.55, color: "#fbbf24" },
        { name: "cone",   w: 0.45, h: 0.65, color: "#fb7185" },
        { name: "block",  w: 0.78, h: 0.62, color: "#a78bfa" },
        { name: "oil",    w: 0.75, h: 0.35, color: "#94a3b8" },
      ];
      const ammoKind = { name: "ammo", w: 0.74, h: 0.56, color: "#60a5fa" };
      const lifeKind = { name: "life", w: 0.72, h: 0.54, color: "#34d399" };

      function kindHP(kindName) {
        if (kindName === "cone") return 1;
        if (kindName === "barrel") return 2;
        if (kindName === "oil") return 2;
        if (kindName === "block") return 4;
        return 2;
      }

      function obstaclePoints(o) {
        const tier = Math.max(1, Math.round((o.baseW * o.baseH) * 10));
        return 10 * tier + 10 * (o.hpMax - 1);
      }

      const SPAWN_DIST = 1700;
      const DESPAWN_DIST = 80;

      function ammoValueBySpeed() {
        const hi = (speedMul < 1.7) ? 3 : (speedMul < 2.6) ? 4 : 5;
        return randInt(1, hi);
      }
      function lifeValueBySpeed() {
        const hi = (speedMul < 2.2) ? 2 : 3;
        return randInt(1, hi);
      }

      function spawnThing() {
        const lane = randInt(0, lanes - 1);

        let kind = null;
        let isAmmo = false;
        let isLife = false;

        if (mode === "scarcity") {
          const ammoProb = clamp(0.14 + (speedMul - 1.0) * 0.03, 0.14, 0.22);
          if (Math.random() < ammoProb) { kind = ammoKind; isAmmo = true; }
        }

        if (!kind) {
          const lifeProb = clamp(0.06 + (speedMul - 1.0) * 0.01, 0.06, 0.10);
          if (Math.random() < lifeProb) { kind = lifeKind; isLife = true; }
        }

        if (!kind) kind = obstacleKinds[randInt(0, obstacleKinds.length - 1)];

        for (const o of obstacles) {
          if (o.lane === lane && Math.abs(o.d - SPAWN_DIST) < 180) return;
        }

        if (isAmmo) {
          const val = ammoValueBySpeed();
          obstacles.push({ lane, d: SPAWN_DIST, baseW: kind.w, baseH: kind.h, kind: "ammo", color: kind.color, isAmmo: true, isLife: false, value: val, hp: 1, hpMax: 1 });
          return;
        }
        if (isLife) {
          const val = lifeValueBySpeed();
          obstacles.push({ lane, d: SPAWN_DIST, baseW: kind.w, baseH: kind.h, kind: "life", color: kind.color, isAmmo: false, isLife: true, value: val, hp: 1, hpMax: 1 });
          return;
        }

        const hp0 = kindHP(kind.name);
        obstacles.push({ lane, d: SPAWN_DIST, baseW: kind.w, baseH: kind.h, kind: kind.name, color: kind.color, isAmmo: false, isLife: false, value: 0, hp: hp0, hpMax: hp0 });
      }

      // Dashes
      const dashMarks = [];
      function initDashes() {
        dashMarks.length = 0;
        const spacing = 140;
        const count = 30;
        for (let i = 0; i < count; i++) dashMarks.push({ d: i * spacing });
      }

      // -----------------------------
      // UI state
      // -----------------------------
      function setOverlay(show, title, sub) {
        overlay.classList.toggle("show", !!show);
        if (title != null) overlayTitle.textContent = title;
        if (sub != null) overlaySub.textContent = sub;
      }

      function setUI() {
        scoreEl.textContent = String(Math.floor(score));
        speedEl.textContent = speedMul.toFixed(1);
        levelEl.textContent = String(level || 1);
        bulletsEl.textContent = (mode === "scarcity") ? String(ammo) : "∞";
        livesEl.textContent = String(lives);
        pauseBtn.textContent = paused ? "Resume" : "Pause";
        updateSoundBtn();
      }

      function resetGame() {
        obstacles.length = 0;
        bullets.length = 0;

        score = 0;
        speedMul = 1.0;

        crashed = false;
        paused = false;
        running = false;

        ammo = (mode === "scarcity") ? 0 : Infinity;
        lives = 1;
        invuln = 0;

        playerLane = 1;

        camSwayX = 0;
        camSwayVel = 0;
        wheelRot = 0;

        spawnTimer = 0;
        spawnEvery = 0.95;

        initDashes();
        setUI();
      }

      // -----------------------------
      // Drawing
      // -----------------------------
      function drawSkyGlow() {
        ctx.save();
        const g = ctx.createRadialGradient(W*0.55, H*0.05, 10, W*0.55, H*0.05, H*0.7);
        g.addColorStop(0, "rgba(94,234,212,0.08)");
        g.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = g;
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      }

      function drawRoadPOV() {
        const topY = horizonY;
        const botY = H;

        const topW = roadTopW;
        const botW = roadBottomW;

        const camTop = camShiftAtY(topY);
        const camBot = camShiftAtY(botY);

        const cxTop = (W/2) + camTop;
        const cxBot = (W/2) + camBot;

        const leftTop = cxTop - topW/2;
        const rightTop = cxTop + topW/2;
        const leftBot = cxBot - botW/2;
        const rightBot = cxBot + botW/2;

        ctx.save();

        // asphalt
        ctx.beginPath();
        ctx.moveTo(leftTop, topY);
        ctx.lineTo(rightTop, topY);
        ctx.lineTo(rightBot, botY);
        ctx.lineTo(leftBot, botY);
        ctx.closePath();

        const g = ctx.createLinearGradient(0, topY, 0, botY);
        g.addColorStop(0, "rgba(255,255,255,0.04)");
        g.addColorStop(1, "rgba(255,255,255,0.015)");
        ctx.fillStyle = g;
        ctx.fill();

        // edges
        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // lane lines (straight in this shifted trapezoid)
        for (let li = 1; li < lanes; li++) {
          const xTop = leftTop + (topW/lanes) * li;
          const xBot = leftBot + (botW/lanes) * li;
          ctx.beginPath();
          ctx.moveTo(xTop, topY);
          ctx.lineTo(xBot, botY);
          ctx.strokeStyle = "rgba(255,255,255,0.11)";
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        // dashes (use camShiftAtY(y) so they stay in correct lane after shifts)
        for (let li = 1; li < lanes; li++) {
          for (const d of dashMarks) {
            const y = projYFromDist(d.d);
            const y2 = projYFromDist(d.d + 70);
            const h = Math.max(6, Math.floor(y2 - y));
            if (y < horizonY || y > H) continue;

            const rw = roadWidthAtY(y);
            const laneW = rw / lanes;
            const cam = camShiftAtY(y);
            const cx = (W/2) + cam;
            const left = cx - rw/2;
            const x = left + laneW * li;

            ctx.fillStyle = "rgba(255,255,255,0.22)";
            ctx.fillRect(x - 2, y, 4, h);
          }
        }

        // center glow (also shifted)
        ctx.globalAlpha = 0.65;
        const glow = ctx.createLinearGradient(0, horizonY, 0, H);
        glow.addColorStop(0, "rgba(94,234,212,0.00)");
        glow.addColorStop(1, "rgba(94,234,212,0.07)");
        ctx.fillStyle = glow;

        const midTopW = topW * 0.24;
        const midBotW = botW * 0.44;

        ctx.beginPath();
        ctx.moveTo(cxTop - midTopW/2, topY);
        ctx.lineTo(cxTop + midTopW/2, topY);
        ctx.lineTo(cxBot + midBotW/2, botY);
        ctx.lineTo(cxBot - midBotW/2, botY);
        ctx.closePath();
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.restore();
      }

      function projectedRectFor(o) {
        const y = projYFromDist(o.d);
        const rw = roadWidthAtY(y);
        const laneW = rw / lanes;

        const cam = camShiftAtY(y);
        const cx = (W/2) + cam;
        const left = cx - rw/2;
        const center = left + laneW * o.lane + laneW/2;

        const w = Math.max(10, Math.floor(laneW * o.baseW));
        const h = Math.max(10, Math.floor(laneW * o.baseH));
        return { x: Math.floor(center - w/2), y: Math.floor(y - h), w, h, yBase: y };
      }

      function drawAmmoBox(o, r) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.33)";
        roundRect(ctx, r.x + 4, r.y + 6, r.w, r.h, 12); ctx.fill();
        ctx.fillStyle = o.color;
        roundRect(ctx, r.x, r.y, r.w, r.h, 12); ctx.fill();
        ctx.fillStyle = "rgba(8, 12, 18, 0.25)";
        roundRect(ctx, r.x + r.w*0.10, r.y + r.h*0.18, r.w*0.80, r.h*0.64, 10); ctx.fill();

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(231,238,252,0.95)";
        ctx.font = `900 ${Math.max(12, Math.floor(r.h*0.55))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText(String(o.value), r.x + r.w/2, r.y + r.h*0.52);

        ctx.fillStyle = "rgba(231,238,252,0.80)";
        ctx.font = `800 ${Math.max(9, Math.floor(r.h*0.20))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText("AMMO", r.x + r.w/2, r.y + r.h*0.82);
        ctx.restore();
      }

      function drawLifeBox(o, r) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.33)";
        roundRect(ctx, r.x + 4, r.y + 6, r.w, r.h, 12); ctx.fill();
        ctx.fillStyle = o.color;
        roundRect(ctx, r.x, r.y, r.w, r.h, 12); ctx.fill();
        ctx.fillStyle = "rgba(8, 12, 18, 0.22)";
        roundRect(ctx, r.x + r.w*0.10, r.y + r.h*0.18, r.w*0.80, r.h*0.64, 10); ctx.fill();

        ctx.fillStyle = "rgba(231,238,252,0.85)";
        ctx.beginPath();
        const cx = r.x + r.w*0.50, cy = r.y + r.h*0.34, rr = Math.min(r.w,r.h)*0.10;
        ctx.arc(cx - rr, cy, rr, 0, Math.PI*2);
        ctx.arc(cx + rr, cy, rr, 0, Math.PI*2);
        ctx.lineTo(cx, cy + rr*2.2);
        ctx.closePath();
        ctx.fill();

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(231,238,252,0.98)";
        ctx.font = `900 ${Math.max(12, Math.floor(r.h*0.55))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText(String(o.value), r.x + r.w/2, r.y + r.h*0.58);

        ctx.fillStyle = "rgba(231,238,252,0.80)";
        ctx.font = `800 ${Math.max(9, Math.floor(r.h*0.20))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillText("LIFE", r.x + r.w/2, r.y + r.h*0.82);
        ctx.restore();
      }

      function drawObstacle(o, r) {
        if (o.isAmmo) return drawAmmoBox(o, r);
        if (o.isLife) return drawLifeBox(o, r);

        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.33)";
        roundRect(ctx, r.x + 4, r.y + 6, r.w, r.h, 12); ctx.fill();

        ctx.fillStyle = o.color;
        roundRect(ctx, r.x, r.y, r.w, r.h, 12); ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.16)";
        roundRect(ctx, r.x + r.w*0.14, r.y + r.h*0.20, r.w*0.72, r.h*0.60, 10); ctx.fill();

        if (o.hpMax > 1) {
          const pad = Math.max(5, Math.floor(r.w*0.10));
          const barW = r.w - pad*2;
          const barH = Math.max(4, Math.floor(r.h*0.10));
          const bx = r.x + pad;
          const by = r.y + Math.max(4, Math.floor(r.h*0.08));
          ctx.fillStyle = "rgba(0,0,0,0.35)";
          roundRect(ctx, bx, by, barW, barH, 4); ctx.fill();
          const frac = clamp(o.hp / o.hpMax, 0, 1);
          ctx.fillStyle = "rgba(231,238,252,0.65)";
          roundRect(ctx, bx, by, barW * frac, barH, 4); ctx.fill();
        }

        ctx.restore();
      }

      function drawBullet(b) {
        const y = projYFromDist(b.d);
        const rw = roadWidthAtY(y);
        const laneW = rw / lanes;

        const cam = camShiftAtY(y);
        const cx = (W/2) + cam;
        const left = cx - rw/2;
        const c = left + laneW * b.lane + laneW/2;

        const w = Math.max(5, Math.floor(laneW * 0.10));
        const h = Math.max(10, Math.floor(laneW * 0.22));
        const x = Math.floor(c - w/2);
        const yy = Math.floor(y - h);

        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(231,238,252,0.9)";
        roundRect(ctx, x, yy, w, h, 8); ctx.fill();
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = "rgba(94,234,212,0.7)";
        roundRect(ctx, x + 2, yy + h*0.25, w - 4, h*0.5, 6); ctx.fill();
        ctx.restore();

        b._rect = { x, y: yy, w, h };
      }

      // cockpit drawing (unchanged)
      function drawCockpit() {
        // windshield vignette
        ctx.save();
        const vg = ctx.createRadialGradient(W*0.5, H*0.42, 80, W*0.5, H*0.42, H*0.75);
        vg.addColorStop(0, "rgba(0,0,0,0.00)");
        vg.addColorStop(1, "rgba(0,0,0,0.52)");
        ctx.fillStyle = vg;
        ctx.fillRect(0,0,W,H);
        ctx.restore();

        // A-pillars + top tint
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.30)";
        ctx.fillRect(0,0,W,Math.floor(H*0.16));
        ctx.fillStyle = "rgba(0,0,0,0.58)";
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(Math.floor(W*0.20),0);
        ctx.lineTo(Math.floor(W*0.30),Math.floor(H*0.40));
        ctx.lineTo(0,Math.floor(H*0.34));
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(W,0);
        ctx.lineTo(Math.floor(W*0.80),0);
        ctx.lineTo(Math.floor(W*0.70),Math.floor(H*0.40));
        ctx.lineTo(W,Math.floor(H*0.34));
        ctx.closePath();
        ctx.fill();

        // subtle glass reflection
        ctx.globalAlpha = 0.35;
        const rg = ctx.createRadialGradient(W*0.72, H*0.10, 10, W*0.72, H*0.10, H*0.6);
        rg.addColorStop(0, "rgba(255,255,255,0.10)");
        rg.addColorStop(1, "rgba(255,255,255,0.00)");
        ctx.fillStyle = rg;
        ctx.fillRect(0,0,W,H);
        ctx.restore();

        // cockpit sides
        ctx.save();
        const baseY = Math.floor(H*0.62);
        ctx.fillStyle = "rgba(6,8,12,0.92)";
        ctx.beginPath();
        ctx.moveTo(0, H);
        ctx.lineTo(0, baseY);
        ctx.quadraticCurveTo(Math.floor(W*0.08), Math.floor(H*0.64), Math.floor(W*0.18), Math.floor(H*0.70));
        ctx.lineTo(Math.floor(W*0.28), H);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(W, H);
        ctx.lineTo(W, baseY);
        ctx.quadraticCurveTo(Math.floor(W*0.92), Math.floor(H*0.64), Math.floor(W*0.82), Math.floor(H*0.70));
        ctx.lineTo(Math.floor(W*0.72), H);
        ctx.closePath();
        ctx.fill();

        // nose cone
        ctx.fillStyle = "rgba(10,14,20,0.95)";
        ctx.beginPath();
        ctx.moveTo(Math.floor(W*0.46), H);
        ctx.lineTo(Math.floor(W*0.54), H);
        ctx.lineTo(Math.floor(W*0.58), Math.floor(H*0.72));
        ctx.lineTo(Math.floor(W*0.42), Math.floor(H*0.72));
        ctx.closePath();
        ctx.fill();

        // nose highlight
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = "rgba(94,234,212,0.10)";
        ctx.beginPath();
        ctx.moveTo(Math.floor(W*0.49), H);
        ctx.lineTo(Math.floor(W*0.51), H);
        ctx.lineTo(Math.floor(W*0.535), Math.floor(H*0.73));
        ctx.lineTo(Math.floor(W*0.465), Math.floor(H*0.73));
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // mirrors
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = "rgba(18,24,38,0.9)";
        roundRect(ctx, Math.floor(W*0.10), Math.floor(H*0.52), Math.floor(W*0.18), Math.floor(H*0.06), 10); ctx.fill();
        roundRect(ctx, Math.floor(W*0.72), Math.floor(H*0.52), Math.floor(W*0.18), Math.floor(H*0.06), 10); ctx.fill();
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = "rgba(231,238,252,0.9)";
        ctx.fillRect(Math.floor(W*0.12), Math.floor(H*0.535), Math.floor(W*0.14), Math.floor(H*0.02));
        ctx.fillRect(Math.floor(W*0.74), Math.floor(H*0.535), Math.floor(W*0.14), Math.floor(H*0.02));
        ctx.restore();

        // steering wheel
        const cx = W*0.5;
        const cy = H*0.88;
        const R = Math.min(W,H)*0.26;
        const rot = wheelRot * Math.PI/180;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rot);

        ctx.lineWidth = Math.max(14, R*0.12);
        ctx.strokeStyle = "rgba(30,36,46,0.95)";
        ctx.beginPath();
        ctx.arc(0,0,R,Math.PI*0.08,Math.PI*0.92,false);
        ctx.stroke();

        ctx.lineWidth = Math.max(10, R*0.08);
        ctx.strokeStyle = "rgba(18,24,38,0.95)";
        ctx.beginPath();
        ctx.arc(0,0,R*0.70,Math.PI*0.10,Math.PI*0.90,false);
        ctx.stroke();

        ctx.fillStyle = "rgba(18,24,38,0.98)";
        ctx.beginPath();
        ctx.arc(0,0,R*0.22,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "rgba(94,234,212,0.25)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0,0,R*0.22,0,Math.PI*2);
        ctx.stroke();

        ctx.globalAlpha = 0.85;
        for (let i=0;i<6;i++){
          const ang = Math.PI*(0.18 + i*0.12);
          const rr = R*0.08;
          ctx.fillStyle = (i%2===0) ? "rgba(94,234,212,0.35)" : "rgba(231,238,252,0.22)";
          ctx.beginPath();
          ctx.arc(Math.cos(ang)*R*0.52, Math.sin(ang)*R*0.52, rr, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = "rgba(10,10,12,0.95)";
        roundRect(ctx, -R*0.90, -R*0.06, R*0.36, R*0.24, 14); ctx.fill();
        roundRect(ctx,  R*0.54, -R*0.06, R*0.36, R*0.24, 14); ctx.fill();
        ctx.restore();

        ctx.restore();
      }

      function render() {
        ctx.clearRect(0,0,W,H);
        drawSkyGlow();
        drawRoadPOV();

        const sortedObs = obstacles.slice().sort((a,b)=> b.d - a.d);
        for (const o of sortedObs) {
          const r = projectedRectFor(o);
          o._rect = r;
          drawObstacle(o, r);
        }

        const sortedBul = bullets.slice().sort((a,b)=> b.d - a.d);
        for (const b of sortedBul) drawBullet(b);

        drawCockpit();

        if (running && paused) {
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.35)";
          ctx.fillRect(0,0,W,H);
          ctx.fillStyle = "rgba(231,238,252,0.92)";
          ctx.font = "800 34px system-ui, -apple-system, Segoe UI, Roboto, Arial";
          ctx.textAlign = "center";
          ctx.fillText("PAUSED", W/2, H/2);
          ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
          ctx.fillStyle = "rgba(231,238,252,0.75)";
          ctx.fillText("Tap Resume / press Space", W/2, H/2 + 28);
          ctx.restore();
        }
      }

      // -----------------------------
      // Gameplay actions
      // -----------------------------
      function grantAmmo(units) {
        if (mode !== "scarcity") return;
        ammo += units * 10;
        setUI();
        SFX.gainAmmo();
      }
      function grantLife(n) {
        lives += n;
        setUI();
        SFX.gainLife();
      }
      function spendLife() {
        if (invuln > 0) return;
        lives -= 1;
        invuln = INVULN_TIME;
        setUI();
        SFX.hitObstacle();
        if (lives <= 0) die();
      }
      function die() {
        crashed = true;
        paused = false;
        running = false;
        SFX.carDies();
        setOverlay(true, "Car Died!", `Final score: ${Math.floor(score)}. Tap Start or press R.`);
        modeRow.style.display = "none";
        levelRow.style.display = "none";
        startRow.style.display = "flex";
      }

      // -----------------------------
      // Movement
      // -----------------------------
      let moveLeftHeld = false;
      let moveRightHeld = false;
      let laneMoveCooldown = 0;
      const laneMoveDelay = 0.12;

      function tryMove(dir) {
        const next = clamp(playerLane + dir, 0, lanes - 1);
        if (next !== playerLane) {
          playerLane = next;
          laneMoveCooldown = laneMoveDelay;
          camSwayVel += dir * 520;
        }
      }

      // -----------------------------
      // Shooting
      // -----------------------------
      let shootHeld = false;
      let shootCooldown = 0;
      const shootDelay = 0.14;
      let shootHeldTimer = 0;

      function shootOnce() {
        if (!running || paused || crashed) return;
        if (!mode || !level) return;
        if (shootCooldown > 0) return;

        if (mode === "scarcity") {
          if (ammo <= 0) return;
          ammo -= 1;
        }

        shootCooldown = shootDelay;
        bullets.push({ lane: playerLane, d: 120 });
        setUI();
        SFX.shoot();
      }

      // -----------------------------
      // Spawning + simulation
      // -----------------------------
      let lastT = 0;
      let spawnTimer = 0;
      let spawnEvery = 0.95;

      function update(dt) {
        speedMul += dt * 0.03;
        speedMul = Math.min(speedMul, 4.0);
        const speed = 660 * speedMul;

        invuln = Math.max(0, invuln - dt);

        spawnEvery = clamp(0.95 - (speedMul - 1.0) * 0.15, 0.35, 0.95);

        laneMoveCooldown = Math.max(0, laneMoveCooldown - dt);
        if (laneMoveCooldown <= 0) {
          if (moveLeftHeld) tryMove(-1);
          else if (moveRightHeld) tryMove(+1);
        }

        // sway dynamics
        camSwayX += camSwayVel * dt;
        camSwayVel *= Math.pow(0.001, dt);
        camSwayX *= Math.pow(0.001, dt);
        camSwayX = clamp(camSwayX, -60, 60);

        // wheel: lane-based target + a bit of sway
        const laneAngle = (playerLane - 1) * 16;
        const swayAngle = camSwayX * 0.18;
        const targetWheel = laneAngle + swayAngle;
        wheelRot += (targetWheel - wheelRot) * (1 - Math.pow(0.001, dt));

        // shooting hold
        shootCooldown = Math.max(0, shootCooldown - dt);
        if (shootHeld) {
          shootHeldTimer += dt;
          if (shootHeldTimer >= shootDelay) {
            shootHeldTimer = 0;
            shootOnce();
          }
        } else shootHeldTimer = 0;

        // road dashes
        for (const dm of dashMarks) dm.d -= speed * dt * 0.85;
        for (const dm of dashMarks) if (dm.d < 0) dm.d += 140 * 30;

        // spawn
        spawnTimer += dt;
        while (spawnTimer >= spawnEvery) {
          spawnTimer -= spawnEvery;
          spawnThing();
          if (speedMul > 2.0 && Math.random() < 0.25) spawnThing();
        }

        // obstacles
        for (let i = obstacles.length - 1; i >= 0; i--) {
          obstacles[i].d -= speed * dt;
          if (obstacles[i].d < -DESPAWN_DIST) obstacles.splice(i, 1);
        }

        // bullets
        const bulletSpeed = 1500;
        for (let i = bullets.length - 1; i >= 0; i--) {
          bullets[i].d += bulletSpeed * dt;
          if (bullets[i].d > SPAWN_DIST + 200) bullets.splice(i, 1);
        }

        // rects
        for (const o of obstacles) o._rect = projectedRectFor(o);
        for (const b of bullets) drawBullet(b); // also sets b._rect

        // bullet hits
        for (let bi = bullets.length - 1; bi >= 0; bi--) {
          const b = bullets[bi];
          let hit = false;

          for (let oi = obstacles.length - 1; oi >= 0; oi--) {
            const o = obstacles[oi];
            if (!aabb(b._rect.x, b._rect.y, b._rect.w, b._rect.h, o._rect.x, o._rect.y, o._rect.w, o._rect.h)) continue;
            hit = true;

            if (o.isLife) {
              if (level === 1) {
                SFX.hitShot();
              } else if (level === 2) {
                obstacles.splice(oi, 1);
                SFX.hitShot();
              } else {
                obstacles.splice(oi, 1);
                lives -= o.value;
                setUI();
                SFX.hitObstacle();
                if (lives <= 0) die();
              }
              break;
            }

            if (o.isAmmo) {
              if (mode === "scarcity") grantAmmo(o.value);
              obstacles.splice(oi, 1);
              break;
            }

            o.hp -= 1;
            SFX.hitShot();
            if (o.hp <= 0) {
              score += obstaclePoints(o);
              obstacles.splice(oi, 1);
              SFX.destroyBox();
            }
            break;
          }

          if (hit) bullets.splice(bi, 1);
        }

        // cockpit collision (lane + distance)
        for (let oi = obstacles.length - 1; oi >= 0; oi--) {
          const o = obstacles[oi];
          if (o.d > COLLIDE_D) continue;
          if (o.lane !== playerLane) continue;

          if (o.isLife) { grantLife(o.value); obstacles.splice(oi,1); continue; }
          if (o.isAmmo) { if (mode === "scarcity") grantAmmo(o.value); obstacles.splice(oi,1); continue; }

          obstacles.splice(oi,1);
          spendLife();
          break;
        }

        setUI();
      }

      function step(t) {
        requestAnimationFrame(step);
        if (!running) { render(); lastT = t; return; }

        const dt = Math.min(0.033, (t - lastT) / 1000 || 0);
        lastT = t;

        if (paused || crashed) { render(); return; }
        update(dt);
        render();
      }

      function togglePause() {
        if (!running || crashed) return;
        paused = !paused;
        setUI();
      }

      function startOrRestart() {
        if (!mode || !level) return;
        resetGame();
        running = true;
        paused = false;
        crashed = false;
        setOverlay(false);
        lastT = performance.now();
        setUI();
      }

      // -----------------------------
      // Inputs
      // -----------------------------
      function onKeyDown(e) {
        if (e.repeat) return;
        const k = e.key.toLowerCase();
        if (k === "arrowleft" || k === "a") { moveLeftHeld = true; e.preventDefault(); ensureAudio(); }
        else if (k === "arrowright" || k === "d") { moveRightHeld = true; e.preventDefault(); ensureAudio(); }
        else if (k === "f") { ensureAudio(); shootOnce(); e.preventDefault(); }
        else if (k === " " || k === "spacebar") { ensureAudio(); togglePause(); e.preventDefault(); }
        else if (k === "r") { ensureAudio(); startOrRestart(); e.preventDefault(); }
      }
      function onKeyUp(e) {
        const k = e.key.toLowerCase();
        if (k === "arrowleft" || k === "a") moveLeftHeld = false;
        if (k === "arrowright" || k === "d") moveRightHeld = false;
      }

      function bindTouchHold(btn, setter) {
        btn.addEventListener("touchstart", (e) => { setter(true); e.preventDefault(); ensureAudio(); }, { passive: false });
        btn.addEventListener("touchend",   (e) => { setter(false); e.preventDefault(); }, { passive: false });
        btn.addEventListener("touchcancel",() => setter(false));
        btn.addEventListener("pointerdown", (e) => { setter(true); e.preventDefault(); ensureAudio(); });
        btn.addEventListener("pointerup",   (e) => { setter(false); e.preventDefault(); });
        btn.addEventListener("pointercancel", () => setter(false));
        btn.addEventListener("pointerleave",  () => setter(false));
      }

      bindTouchHold(leftBtn,  (v) => { moveLeftHeld = v; if (v) moveRightHeld = false; });
      bindTouchHold(rightBtn, (v) => { moveRightHeld = v; if (v) moveLeftHeld = false; });
      bindTouchHold(shootBtn, (v) => { shootHeld = v; if (v) shootOnce(); });

      pauseBtn.addEventListener("click", () => { ensureAudio(); togglePause(); });
      restartBtn.addEventListener("click", () => { ensureAudio(); startOrRestart(); });
      startBtn.addEventListener("click", () => { ensureAudio(); startOrRestart(); });

      soundBtn.addEventListener("click", () => { ensureAudio(); soundOn = !soundOn; setUI(); });

      document.getElementById("stage").addEventListener("pointerdown", () => {
        if (!mode || !level) return;
        ensureAudio();
        if (!running) startOrRestart();
      });

      window.addEventListener("keydown", onKeyDown, { passive: false });
      window.addEventListener("keyup", onKeyUp);

      // -----------------------------
      // Overlay selection
      // -----------------------------
      function showModePicker() {
        mode = null; level = null;
        running = false; paused = false; crashed = false;

        modeRow.style.display = "flex";
        levelRow.style.display = "none";
        startRow.style.display = "none";

        setOverlay(true, "Choose Mode", "Pick a mode to start.");
        hintSub.textContent = "On phone: use the fixed bottom Left/Shoot/Right buttons.";
        setUI();
        computeStageHeight();
      }

      function chooseMode(nextMode) {
        mode = nextMode;
        level = null;

        modeRow.style.display = "none";
        levelRow.style.display = "flex";
        startRow.style.display = "none";

        setOverlay(true, "Choose Level",
          (mode === "infinite")
            ? "Infinite Shoot: unlimited bullets. Select Level 1/2/3."
            : "Scarcity: start with 0 bullets. Collect AMMO. Select Level 1/2/3."
        );

        setUI();
        computeStageHeight();
      }

      function chooseLevel(nextLevel) {
        level = nextLevel;

        levelRow.style.display = "none";
        startRow.style.display = "flex";

        const lvTxt =
          (level === 1) ? "Level 1 (Easy): shooting LIFE box has no effect."
          : (level === 2) ? "Level 2 (Normal): shooting LIFE box destroys it, no life change."
          : "Level 3 (Advanced): shooting LIFE box reduces life by its number.";

        setOverlay(true, "Ready!", `${lvTxt} Tap Start (or tap the game).`);

        resetGame();
        computeStageHeight();
      }

      modeInfiniteBtn.addEventListener("click", () => { ensureAudio(); chooseMode("infinite"); });
      modeScarcityBtn.addEventListener("click", () => { ensureAudio(); chooseMode("scarcity"); });

      lvl1Btn.addEventListener("click", () => { ensureAudio(); chooseLevel(1); });
      lvl2Btn.addEventListener("click", () => { ensureAudio(); chooseLevel(2); });
      lvl3Btn.addEventListener("click", () => { ensureAudio(); chooseLevel(3); });

      backBtn.addEventListener("click", () => { ensureAudio(); showModePicker(); });

      howBtn.addEventListener("click", () => {
        const modeTxt =
          (mode === "infinite")
            ? "Mode: Infinite Shoot\n• Bullets are unlimited (∞)."
            : "Mode: Scarcity\n• You start with 0 bullets.\n• AMMO boxes (blue): number is in tens (1=10,2=20,...).\n• Hit or shoot AMMO to gain bullets.\n• Shooting costs 1 bullet.";
        const lvlTxt =
          (level === 1) ? "Level 1: shooting LIFE box has no effect."
          : (level === 2) ? "Level 2: shooting LIFE box destroys it, no life change."
          : "Level 3: shooting LIFE box reduces life by its number.";
        alert(
          "Cockpit POV:\n• Player is a fixed cockpit.\n• You move lanes (left/right).\n• Obstacles come toward you.\n\n" +
          modeTxt + "\n\nCommon:\n• Only destroying obstacle boxes gives points.\n• LIFE boxes (green): hit to gain life.\n" +
          lvlTxt
        );
      });

      // Init
      updateSoundBtn();
      initDashes();
      computeStageHeight();
      showModePicker();
      requestAnimationFrame(step);

      setTimeout(computeStageHeight, 50);
      setTimeout(computeStageHeight, 250);
    })();
  </script>
</body>
</html>